##### 1. 增加运算效率

>  扩容时使用位运算<<，计算除余时使用(n-1)&hash，这些位运算都可以增加效率 

##### 2. 减少扩容后数据移动造成的hash冲突增多,并且数据迁移减少一半，同时方便操作

改变数据长度之后，原来存储的数据需要重新计算数组下标，找到新的存储位置，如果数组长度设置不当，则容易出现扩容之后，反而造成hash冲突变多，这样扩容就没有意义了。当使用2的倍数进行扩容时，hash冲突只会减少，最坏的情况也就是hash冲突不变。并且这种操作还可以对链表进行优化操作，通过计算新 **下标>老数组长度** 判断数据需不需要移动，这样整体只迁移一半的数据就完成了扩容。 

> 只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”
>
> 省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点