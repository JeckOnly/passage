# 深入理解Java虚拟机

## JVM组成

![](https://gitee.com/StarMika/myimgs/raw/master/img/202203031050438.png)

- **「Class loader(类装载)：」** 根据给定的全限定名类名(如：java.lang.Object)来装载class文件到运行时数据区的方法区中。
- **「Execution engine（执行引擎）」**：执行class的指令。
- **「Native Interface(本地接口)：」** 与native lib交互，是其它编程语言交互的接口。
- **「Runtime data area(运行时数据区域)」**：即我们常说的JVM的内存。

首先通过编译器把 Java源代码转换成字节码，Class loader(类装载)再把字节码加载到内存中，将其放在运行时数据区的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎，将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口来实现整个程序的功能。

## 运行时数据区

![图 25-1  JDK1.6、JDK1.7、JDK1.8，内存模型演变](https://bugstack.cn/assets/images/2020/interview/interview-25-1.png)

线程共享：

1. 堆
2. 方法区

线程私有：

1. 程序计数器
2. 虚拟机栈
3. 本地方法栈

### 程序计数器

- 较小的内存空间、线程私有，记录当前线程所执行的字节码行号。
- 如果执行 Java 方法，计数器记录虚拟机字节码当前指令的地址，本地方法则为空。
- 这一块区域没有任何 OutOfMemoryError 定义。

字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。

为了线程切换后能恢复到正确的执行位置，每条线程都有一个独立的程序计数器，各线程之间计数器互不影响，独立存储。

如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则为空（Undefined）。

注意：程序计数器是唯一一个不会出现 `OutOfMemoryError` 的内存区域，它的生命周期就是线程的生命周期。

### 虚拟机栈

- 每一个方法在执行的同时，都会创建出一个栈帧，用于存放局部变量表、操作数栈、动态链接、方法出口、线程等信息。
- 方法从调用到执行完成，都对应着栈帧从虚拟机中入栈和出栈的过程。
- 最终，栈帧会随着方法的创建到结束而销毁。

虚拟机栈是线程私有的，它的生命周期和线程相同。

虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，JVM都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

### 本地方法栈

和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

### 方法区

![](https://gitee.com/StarMika/myimgs/raw/master/img/202203031042603.png)

用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码缓存数据。

虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 **Non-Heap（非堆）**，目的应该是与 Java 堆区分开来。

#### 运行时常量池

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

保存Class文件中描述的符号引用和由符号引用翻译出来的直接引用也存储在运行时常量池中。

它并不要求常量一定只有在编译期才能产生，也就是并非编译期间将常量放在常量池中，运行期间也可以将新的常量放入常量池中，String 的 intern 方法就是一个典型的例子。

#### 方法区和永久代的关系

《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。 

也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。

#### 方法区在哪

在整个JVM堆内存之中实际上将内存分为了三部分新生带
（年轻代）：新对象和没达到一定年龄的对象都在年轻代 
老年代：被长时间使用的对象，老年代的内存空间应该要比年轻代更大 
元空间（JDK1.8之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8之前是占用JVM内存，JDK1.8之后直接使用物理内存 

![元空间与永久代](https://i.stack.imgur.com/7d0Nu.jpg)

[元空间在物理内存](https://stackoverflow.com/questions/39675406/difference-between-metaspace-and-native-memory-in-java)

#### 为什么要将永久代替换为元空间

1. 整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。
2. 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。
3. 在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。

### 堆

堆在虚拟机启动时创建，是所有线程共享的一块内存区域，用来存放对象实例，**几乎**所有的对象实例以及数组都在这里分配内存。根据《Java虚拟机规范》的规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。

Java 世界中“几乎”所有的对象都在堆中分配。

#### 逃逸分析

**「对象一定分配在堆中吗？」** 不一定的，JVM通过**「逃逸分析」**，那些逃不出方法的对象会在栈上分配。

**「什么是逃逸分析？」**

逃逸分析(Escape Analysis)，是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围，从而决定是否要将这个对象分配到堆上。

当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他方法或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。通俗点讲，如果一个对象的指针被多个方法或者线程引用时，那么我们就称这个对象的指针发生了逃逸。

好处：

- 栈上分配，可以降低垃圾收集器运行的频率。
- 同步消除，如果发现某个对象只能从一个线程可访问，那么在这个对象上的操作可以不需要同步。
- 标量替换，把对象分解成一个个基本类型，并且内存分配不再是分配在堆上，而是分配在栈上。这样的好处有，一、减少内存使用，因为不用生成对象头。二、程序内存回收效率高，并且GC频率也会减少。

#### 堆内存

堆是垃圾收集器管理的主要区域，因此也被称作GC堆。从垃圾回收的角度来看，收集器基本都采用分代垃圾收集算法，所以堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、Survivor0、Survivor1 空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。

分两个survivor原因是一次gc后survivor存进了存活对象，但是survivor以后会有对象死去，要把死去的对象怎么清理呢，所以要有一块survivor 区永远保证是空的，gc后 survivor FROM存活对象复制到survivor TO，然后FROM和TO指针替换，永远保持survivor FROM是空的。

在 JDK 7 版本及之前，堆内存被通常被分为下面三部分：

1. 新生代内存(Young Generation)
2. 老生代(Old Generation)
3. 永久代(Permanent Generation)

![JVM堆内存结构-JDK7](https://images.xiaozhuanlan.com/photo/2020/922e959f70347b00b9a960bdbd0f5607.png)

JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了，取而代之是元空间，元空间使用的是直接内存。

![JVM堆内存结构-JDK7](https://images.xiaozhuanlan.com/photo/2020/4b64a69f721803e87171fee377a65436.png)

堆内存结构：新生代、老年代。

新生代：Eden区、S0区、S1区，比例为 8:1:1 ，并不是所有垃圾收集器按照这种情况进行分区。比例为 8:1:1 是基于标记复制的算法思想。

上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。

堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：

1. `OutOfMemoryError: GC Overhead Limit Exceeded` ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
2. `java.lang.OutOfMemoryError: Java heap space` :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发`java.lang.OutOfMemoryError: Java heap space` 错误。(和本机物理内存无关，和你配置的内存大小有关！)

### 两种错误

- `StackOverFlowError`： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。
- `OutOfMemoryError`： 如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。

## 栈帧

### 栈帧结构

JVM以方法作为最基本的执行单元，“栈帧”（Stack Frame）则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。

每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。

以Java程序的角度来看，同一时刻、同一条线程里面，在调用堆栈的所有方法都同时处于执行状态。而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的，其被称为“当前栈帧”（Current Stack Frame），与这个栈帧所关联的方法被称为“当前方法”（Current Method）。**每一个方法从调用开始到执行结束的过程，对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程**

#### 1：局部变量表

局部变量表是一组变量值的存储空间，用于存放**方法参数和方法内部定义的局部变量**。这些参数在.java文件编译为.class文件时，直接存储到方法表下的属性表的Code属性中。Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。

局部变量表的容量以变量槽为最小单位，《Java虚拟机规范》中并没有明确指出一个变量槽应占用的内存空间大小，只是很有导向性地说到每个变量槽都应该能存放一个boolean、byte、char、short、int、float、reference（reference类型表示对一个对象实例的引用）或returnAddress类型的数据。

当一个方法被调用时，Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递。

局部变量表中的变量槽是可以重用的，如果当前字节码程序计数器的值已经超出了某个变量的作用域，那这个变量对应的变量槽就可以交给其他变量来重用。

当一个方法被调用时，Java虚拟机会使用局部变量表来完成实参到形参的传递。如果执行的是实例方法（没有被static修饰的方法），那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数。

局部变量不存在类变量的准备阶段，如果一个局部变量定义了但没有赋初始值，那它是完全不能使用的。

#### 2：操作数栈

操作数栈是辅助方法内部完成变量读写计算用的先入后出栈。操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。

操作数栈的最大深度在编译的时候被写入到Code属性的max_stacks数据项之中。

当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。譬如在做算术运算的时候是通过将运算涉及的操作数栈压入栈顶后调用运算指令来进行的，又譬如在调用其他方法的时候是通过操作数栈来进行方法参数的传递。

#### 3：动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接，即在方法中调用其他方法时用来连接其他方法。

字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接。

#### 4：方法返回地址

方法正常退出时，主调方法的程序计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。

方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中就一般不会保存这部分信息。

## 方法调用的两种形式

### 解析

所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为解析（Resolution）。

Java语言里符合这个条件的方法共有静态方法、私有方法、实例构造器、父类方法4种，再加上被final修饰的方法（尽管它使用invokevirtual指令调用），这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为“非虚方法”（Non-Virtual Method），与之相反，其他方法就被称为“虚方法”（Virtual Method）。

解析调用一定是个静态的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用，不必延迟到运行期再去完成。

### 分派

> 静态分派

**静态类型来决定方法执行版本的分派动作，都称为静态分派。**

静态类型和实际类型在程序中都可能会发生变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。

静态分派的最典型应用表现就是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。

> 动态分派

与重写（Override）有着很密切的关联。

**我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。**

方法调用指令invokevirtual的运行时解析过程大致分为以下几步：

1. 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。
2. 如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回java.lang.IllegalAccessError异常。
3. 否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。
4. 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。

正是因为invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的invokevirtual指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法版本，这个过程就是Java语言中方法重写的本质。

方法的接收者与方法的参数统称为方法的宗量，Java语言是一门静态多分派、动态单分派的语言。

> 虚拟机动态分派的实现

动态分派是执行非常频繁的动作，真正运行时一般不会如此频繁地去反复搜索类型元数据。面对这种情况，一种基础而且常见的优化手段是为类型在方法区中建立一个虚方法表。

虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。

## 介绍下对象

### 对象的创建

![Java创建对象的过程](https://images.xiaozhuanlan.com/photo/2020/e2cce6843053455fa8db43c78a8bc3b3.png)

1. 类加载检查。
   虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。（因为此时很可能不知道具体的类是什么，所以这里使用的是符号引用。）如果发现这个类没有经过类加载的过程，那么就执行相应的类加载过程。

2. 分配内存。

   在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。

3. 初始化零值。
   内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

4. 设置对象头。
   初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

5. 执行 init 方法。
   在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

分配内存的两种方式：

![图片](https://gitee.com/StarMika/myimgs/raw/master/img/202203031103111.png)

- 一般情况下，JVM的对象都放在堆内存中（发生逃逸分析除外）。当类加载检查通过后，Java虚拟机开始为新生对象分配内存。如果Java堆中内存是绝对规整的，所有被使用过的的内存都被放到一边，空闲的内存放到另外一边，中间放着一个指针作为分界点的指示器，所分配内存仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的实例，这种分配方式就是“**「指针碰撞」**”。

- 如果堆内存中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，不可以进行指针碰撞，虚拟机必须维护一个列表，记录哪些内存是可用的，在分配的时候从列表找到一块大的空间分配给对象实例，并更新列表上的记录，这种分配方式就是“**「空闲列表」**”。

对象创建在虚拟机中是非常频繁的行为，可能存在线程安全问题。如果一个线程正在给A对象分配内存，指针还没有来的及修改，同时另一个为B对象分配内存的线程，仍引用这之前的指针指向，这就出**「问题」**了。

可以把内存分配的动作按照线程划分在不同的空间之中进行，每个线程在Java堆中预先分配一小块内存,这就是**「TLAB（Thread Local Allocation Buffer，本地线程分配缓存）」** 。虚拟机通过-XX:UseTLAB设定它的。
[TLAB介绍](https://dzone.com/articles/thread-local-allocation-buffers)

所以，上述两种分配方式选择哪个，取决于 Java 堆是否规整来决定。在一些垃圾收集器的实现中，Serial、ParNew 等带压缩整理过程的收集器，使用的是指针碰撞；而使用 CMS 这种基于清除算法的收集器时，使用的是空闲列表，具体的垃圾收集器我们后面会聊到。

### 对象的内存布局

![对象头](https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGAgjxrnrs8WQMbo013akCASy10CFkxAhicOKGvSy7oibswhX1yengyY5E3EBWNns3VdHkGRym1Cfxw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

1. 对象头包含两部分信息：

   - Mark Word（标记字段）：用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。
   - Klass Pointer（类型指针）：Class对象的类型指针，Jdk1.8默认开启指针压缩后为4字节，关闭指针压缩（`-XX:-UseCompressedOops`）后，长度为8字节。其指向的位置是对象对应的Class对象（其对应的元数据对象）的内存地址。
     对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。
2. 实例数据：包括对象的所有成员变量，大小由各个成员变量决定，比如：byte占1个字节8比特位、int占4个字节32比特位。
3. 是对齐填充：这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。

> 64位的JVM在new一个Object创建一个对象在Java中占了多少内存

对象头MarkWord占8字节，Klass Pointer8字节，对象实例0字节，padding 0字节，为16字节。

默认使用指针压缩将Klass Pointer压缩为4字节，但是padding填充4字节，所以还是16字节。

### 对象的两种访问定位方式

建立对象就是为了使用对象，程序通过虚拟机栈的局部变量表中的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有两种：使用句柄和直接指针。

1. **句柄：** 如果使用句柄的话，那么堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；

   ![对象的访问定位-使用句柄](https://images.xiaozhuanlan.com/photo/2020/a902849be548efa99760deafdfa726c5.png)

2. **直接指针：** 如果使用直接指针访问，reference 中存储的直接就是堆中对象的地址。  

   ![对象的访问定位-直接指针](https://images.xiaozhuanlan.com/photo/2020/a22870669795f8da8f8d0a71b89d340c.png)

这两种对象访问方式各有优势。

1. 使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。
2. 使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。

### 强、软、弱、虚引用

1. **强引用（StrongReference）**

   在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。当内存空间不足，JVM宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会回收具有强引用的对象来解决内存不足问题。

2. **软引用（SoftReference）**

   如果内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。

3. **弱引用（WeakReference）**

   弱引用与软引用的区别在于：具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器扫描内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。

4. **虚引用（PhantomReference）**

   虚引用顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。

   虚引用主要用来跟踪对象被垃圾回收的活动。

特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。

### 判断一个常量是废弃常量

假如在字符串常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。

### 判断一个类是无用的类

类需要同时满足下面 3 个条件才能算是 **“无用的类”** ：

1. 该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。
2. 加载该类的 `ClassLoader` 已经被回收。
3. 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

## 垃圾回收

### 对象移动过程

![f1c74f1573aeb95fd49d2ccf780ef973](https://gitee.com/StarMika/myimgs/raw/master/img/f1c74f1573aeb95fd49d2ccf780ef973.png)

项目刚刚开始运行，也就是JVM刚把这个项目加载进来，这时Minor GC、Full GC 都没有发生。项目运行后new 的对象会放到Eden区，一段时间后进行了第一次Minor GC，这次Minor GC只针对Eden区，在Eden区存活的对象会移动到S0且年龄加1，并清空Eden区。

此时Eden区为空，new的对象会进入Eden区，进行的第二次垃圾回收会同时回收Eden区和S0区，并将Eden区和S0区存活的对象移动到S1区，从S0区移动过去的对象年龄变为2岁，从Eden区移动过去的对象年龄变为1岁，同时清空Eden区和S0区。这时Eden区为空，S0区为空，S1区包含年龄为1岁和2岁的存活对象，JVM将S0区和S1区角色进行互换，此时Eden区为空，S0有对象，S1没有对象，这次只是角色互换，不是内存数据的复制。

程序继续运行，对象继续在new，新的对象放到Eden区。这时进行第三次垃圾回收，同时回收Eden区和S0区，Eden区和S0区存活的对象会移动到S1区，Eden区中移动的对象为一岁，S0区移动的对象1岁变为2岁、2岁变为3岁，然后清空Eden区和S0区，再次对S0区和S1区进行角色互换。此后依次进行下去。

**什么时候进入老年代：**

1. JVM默认年龄到达15岁的对象进入老年代。
2. 创建的大对象占用的内存超过了JVM设置的 `-XX:MaxTenuringThreshold` ，超过了这个值的对象不会创建在Eden区，直接创建在老年代。
3. Survivor区中相同年龄所有对象大小总和大于Survivor区空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代。
4. Eden区存活的对象总大小超过了其中一个Survivor区，直接放入老年代。所以说年轻代的空间利用率只能到90%。

> 为什么有S0和S1

因为Eden区和Survivor区中间需要有一个缓冲的内存。每一次垃圾回收至少有一个空的Survivor区，空闲的Survivor区为了承载Eden区和S0区垃圾回收后存活对象的放置，并且清空Eden和S0区，这样做避免了Eden区和S0区的空间碎片化。

### 进行GC的区域

针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：

部分收集 (Partial GC)：

- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

整堆收集 (Full GC)：收集整个堆和方法区。

### 空间分配担保

在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看

`-XX：HandlePromotionFailure`参数的设置值是否允许担保失败（Handle Promotion Failure）；

如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者-XX：HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。

### 判断对象是否存活

#### 引用计数法

给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。

**这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。** 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。
[Python的垃圾回收](https://zhuanlan.zhihu.com/p/108683483)

#### 可达性分析算法

![可达性分析算法](https://gitee.com/StarMika/myimgs/raw/master/img/877ec038afed7867f93848ffc836bc4f.png)

这个算法的基本思想就是通过一系列的称为 GC Roots 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可达的，则证明此对象是不可能再被使用的。对象不可达就会在三色标记算法下标记为白色不可达，最终引发垃圾回收。

可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能够进行分析，这意味着必须全程冻结用户线程的运行。

#### GC Roots 是什么

可作为 GC Roots 的对象包括下面几种:

1. 虚拟机栈的栈帧中的局部变量表中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
2. 本地方法栈中本地方法引用的对象。
3. 方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
4. 方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
5. JVM内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象，系统类加载器。
6. 所有被同步锁（synchronized关键字）持有的对象。
7. 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

#### 什么是引用链

对象中的引用类型，强、软、弱、虚引用。

#### 对象不可达意味什么

意味着这个对象将被回收，但不会立即回收这个对象。

在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。

如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。

任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行。

#### 三色标记

![image-20220223135154311](https://gitee.com/StarMika/myimgs/raw/master/img/202202231351415.png)

在三色标记法中，把从GC Roots开始遍历的对象标记为以下三种颜色：

1. **白色：**表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。
2. **灰色：**表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。
3. **黑色：**表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。

三色标记法会造成两种问题，这两种问题所出现的环境都是由于**用户环境和收集器并行工作造成的** 。当用户线程正在修改引用关系，此时收集器在回收引用关系，此时就会造成把原本已经消亡的对象标记为存活，如果出现这种状况的话，问题不大，下次再让收集器重新收集一波就完了，但是还有一种情况是把存活的对象标记为死亡，这种状况就会造成不可预知的后果。

当且仅当以下两个条件同时满足时，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色：

- 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
- 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。

1. **增量更新：**要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。

2. **原始快照：**要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。

以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。

CMS是基于增量更新来做并发标记的，G1、Shenandoah则是用原始快照来实现。

#### 跨代引用

跨代引用：年轻代的对象被老年代的对象所引用，或相反。

那我们进行 Minor GC 的时候不光要管 GC Roots，还有再去遍历老年代（老年代的对象很多），这个性能问题就很大了。

为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集（Remembered Set）的数据结构，用以避免把整个老年代加进GC Roots扫描范围。
[讲讲分代收集与三个分代假说](https://jishuin.proginn.com/p/763bfbd75988)
[为什么跨代引用是GC root](https://www.jianshu.com/p/671495682e46)

#### 记忆集

![img](https://gitee.com/StarMika/myimgs/raw/master/img/d105b2c08c384899b7b4c5436988f11b~tplv-k3u1fbpfcp-watermark.awebp)

记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。前面定义中提到记忆集其实是一种“抽象”的数据结构，抽象的意思是只定义了记忆集的行为意图，并没有定义其行为的具体实现。

如图中的记忆集，在年轻代建立的一个数据结构，他把老年代划分为N个区域，标志出哪个区域会存在跨代引用。收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了，并不需要了解这些跨代指针的全部细节。

> 卡表

卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。关于卡表与记忆集的关系，按照Java语言中HashMap与Map的关系来类比理解。

对于HotSpot虚拟机来说，卡表的实现方式就是一个字节数组。

```java
CARD_TABLE [this address >> 9] = 0;
```

这段代码代表着卡表标记的的逻辑。实际上卡表就是映射了一块块的内存地址，这些内存地址块称为**卡页**，从代码可以看出每个卡页的大小就是2^9=512字节。

如果转换为16进制，数组的0，1号元素就映射为0x0000～0x01FF(0-511)、0x0200～0x03FF(512-1023)内存地址的卡页。

![img](https://gitee.com/StarMika/myimgs/raw/master/img/fe1c468607af4158a1ab499bb6dfab61~tplv-k3u1fbpfcp-watermark.awebp)



一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏（Dirty），没有则标识为0。

在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。

有了卡表，我们就不需要去在发生MinorGC的时候扫描整个老年代了，性能得到了极大的提升。

#### 写屏障

卡表元素何时变脏的答案：有其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻。

写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，在引用对象赋值时会产生一个环形（Around）通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。

### 垃圾收集算法

#### 标记-清除算法

<img src="https://gitee.com/StarMika/myimgs/raw/master/img/63707281.jpg" alt="63707281" style="zoom:50%;" />

算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。

标记过程就是对象是否属于垃圾的判定过程，它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：

1. 执行效率不稳定：如果堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；
2. 空间问题：标记清除后会产生不连续的空间碎片

#### 标记-复制算法

<img src="https://gitee.com/StarMika/myimgs/raw/master/img/90984624.jpg" alt="90984624" style="zoom:50%;" />

解决标记-清除算法面对大量可回收对象时执行效率低和产生空间碎片的问题。

它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

1. 如果内存中多数对象都是存活的，这种算法将会产生大量的内存空间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象。
2. 每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。
3. 可用内存缩小为原来一半，浪费空间。

> Appel式回收，优化的半区复制分代策略

Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被“浪费”的。

当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。

#### 标记-整理算法

![ce94511b6fb2aab8e389ef731879562f](https://gitee.com/StarMika/myimgs/raw/master/img/ce94511b6fb2aab8e389ef731879562f.jpg)

根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

是否移动存活对象的问题：

1. 移动存活对象，更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行。
2. 不移动存活对象，弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。
3. 和稀泥式，内存碎片少时不移动，碎片多时移动。

是否移动对象都存在弊端：
1. 移动则内存回收时会更复杂，不移动则内存分配时会更复杂。
2. 从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。

#### 分代收集算法

当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。

而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。

### 垃圾收集器



![image-20220130203449576](https://gitee.com/StarMika/myimgs/raw/master/img/image-20220130203449576.png)

如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。

我们能做的就是根据具体应用场景选择适合自己的垃圾收集器。

#### 什么是世界停顿

进行垃圾回收的过程中，会涉及对象的移动。为了保证对象引用更新的正确性，必须暂停所有的用户线程，像这样的停顿，虚拟机设计者形象描述为**「Stop The World」**。

在HotSpot中，有个数据结构（映射表）称为**「OopMap」**。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，记录到OopMap。在即时编译过程中，也会在**「特定的位置」**生成 OopMap，记录下栈上和寄存器里哪些位置是引用。

#### Serial 收集器

![d648735b8b88d4f90fcf42d5df60955b](https://gitee.com/StarMika/myimgs/raw/master/img/d648735b8b88d4f90fcf42d5df60955b.jpg)

新生代收集器采用标记复制算法。

Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。它是单线程收集器，它的 “单线程” 的意义不只是它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ Stop The World），直到它收集结束。

迄今为止，它依然是HotSpot虚拟机运行在**客户端模式**下的默认新生代收集器，有着优于其他收集器的地方，那就是简单而高效（与其他收集器的单线程相比），对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）最小的；对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。

#### ParNew收集器

![aa39775571507321fcb846723d1a338f](https://gitee.com/StarMika/myimgs/raw/master/img/aa39775571507321fcb846723d1a338f.jpg)

新生代收集器，采用复制算法。

ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略、线程停顿、内存回收分配等等）和 Serial 收集器完全一样。

它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器）配合工作。

#### Parallel Scavenge 收集器

![aa39775571507321fcb846723d1a338f (1)](https://gitee.com/StarMika/myimgs/raw/master/img/aa39775571507321fcb846723d1a338f%20(1).jpg)

新生代收集器，采用标记复制算法。这是 JDK1.8 默认收集器

关注点是吞吐量来更高效率的利用 CPU。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。

<img src="https://gitee.com/StarMika/myimgs/raw/master/img/image-20220102180705110.png" alt="image-20220102180705110" style="zoom:67%;" />

 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。

#### Serial Old收集器

老年代采用标记-整理算法。

Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。

#### Parallel Old 收集器

老年代采用标记-整理算法。

Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。

#### CMS 收集器

![9238539c9071f598e8de7e8fd0d5bd1a](https://gitee.com/StarMika/myimgs/raw/master/img/9238539c9071f598e8de7e8fd0d5bd1a.jpg)

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的老年代收集器。它非常符合在注重用户体验的应用上使用。

CMS收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。

从名字中的`Mark Sweep`这两个词可以看出，CMS 收集器是一种 “标记-清除”算法实现的。

整个过程分为四个步骤：

- **初始标记：** 暂停所有的其他线程，并记录下直接与GC Roots相连的对象，速度很快 。需要`Stop The World`
- **并发标记：**从GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；
- **重新标记：** 重新标记阶段就是为了修正并发标记期间，因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。需要`Stop The World`
- **并发清除：** 清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。

缺点：

1. 对CPU资源敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程而导致应用程序变慢，降低总吞吐量。CMS默认启动的回收线程数是（处理器核心数量+3）/ 4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源。
2. 无法处理浮动垃圾。在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。
3. 它使用的回收算法“标记-清除”算法会导致收集结束时会有空间碎片产生。

#### Garbage First收集器

G1 (Garbage-First) 是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征。

G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。

Region中还有一类特殊的Humongous区域，专门用来存储大对象。只要大小超过了一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数`-XX：G1HeapRegionSize`设定，取值范围为1MB～32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中。

G1收集器以Region作为单次回收的最小单元，来建立一个可预测的停顿时间模型，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个堆中进行全区域的垃圾收集。

G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间`-XX：MaxGCPauseMillis`，优先选择回收价值最大的 Region，这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率。

**G1收集器的运作过程大致可划分为以下四个步骤：**

1. **初始标记：**仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程`Stop the world`，但耗时很短。

2. **并发标记：**从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB（原始快照）记录下的在并发时有引用变动的对象。

3. **最终标记：**对用户线程做另一个短暂的暂停`Stop the world`，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB（原始快照）记录。

4. **筛选回收：**负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。

   根据用户设定的收集时间`-XX：MaxGCPauseMillis`，然后去计算要回收哪一部分区域，保证时间可预测模型。

> 将Java堆分成多个独立Region后，Region里面存在的跨Region引用对象如何解决？

使用记忆集避免全堆作为GC Roots扫描。它的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。

> 在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？

CMS收集器采用增量更新算法实现，而G1收集器则是通过原始快照（SATB）算法来实现的。

> 垃圾收集对用户线程的影响在回收过程中新创建对象的内存分配上

G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。

### 算法细节

#### 根节点枚举

根节点枚举发生在垃圾收集算法的标记阶段。

垃圾收集器在根节点枚举这一步骤时都是必须暂停用户线程的，根节点枚举必须在一个能保障一致性的快照中才得以进行，这里“一致性”的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况，若这点不能满足的话，分析结果准确性也就无法保证。这是导致垃圾收集过程必须停顿所有用户线程的其中一个重要原因。

GC Roots查找引用链和三色标记都需要一致性快照。

#### 安全点

**安全点：**在垃圾收集过程中让所有用户线程达到的特定的位置，这个位置不会产生新的对象，也不会影响项目的执行，能让垃圾收集安全的进行下去。

有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。

安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的，**方法调用、循环跳转、异常跳转**等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。

#### 安全区域

安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。

## 字节码指令

### 字节码

在 Java 中，JVM 可以理解的代码就叫做`字节码`（即扩展名为 `.class` 的文件）。

Java可以“一次编译，到处运行”，一是因为JVM针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，都可以编译生成固定格式的字节码（.class文件）供JVM使用。

之所以被称之为字节码，是因为字节码文件由十六进制值组成，而JVM以两个十六进制值为一组，即以字节为单位进行读取。在Java中一般是用javac命令编译源代码为字节码文件，一个.java文件从编译到运行的示例如图所示。

![Java运行示意图](https://gitee.com/StarMika/myimgs/raw/master/img/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f696d6167652d32303231303231393136353633303838382e706e67)

### 字节码与数据类型

并非每种数据类型和每一种操作都有对应的指令。

大部分指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。

## Class文件

### Class文件结构

Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8个字节进行存储。

![类文件字节码结构组织示意图](https://images.xiaozhuanlan.com/photo/2020/d8dc3aaa58378fb546049cd0e2830e4c.png)

```java
ClassFile {
    u4             magic; //Class 文件的标志
    u2             minor_version;//Class 的小版本号
    u2             major_version;//Class 的大版本号
    u2             constant_pool_count;//常量池的数量
    cp_info        constant_pool[constant_pool_count-1];//常量池
    u2             access_flags;//Class 的访问标记
    u2             this_class;//当前类
    u2             super_class;//父类
    u2             interfaces_count;//接口
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
    u2             fields_count;//Class 文件的字段属性
    field_info     fields[fields_count];//一个类会可以有多个字段
    u2             methods_count;//Class 文件的方法数量
    method_info    methods[methods_count];//一个类可以有个多个方法
    u2             attributes_count;//此类的属性表中的属性数
    attribute_info attributes[attributes_count];//属性表集合
}
```

### 魔数

所有的.class文件的前四个字节都是魔数（Magic Number），魔数的固定值为：0xCAFEBABE。

魔数放在文件开头，JVM可以根据文件的开头来判断这个文件是否可能是一个.class文件，如果是，才会继续进行之后的操作。

一些视频照片也会使用魔数来标志文件类型。

### 文件版本

版本号为魔数之后的4个字节，前两个字节表示次版本号（Minor Version），后两个字节表示主版本号（Major Version）。

这里解决Java的兼容性问题，高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件，因为《Java虚拟机规范》在Class文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。

JDK 1.8 的版本号为 52.0 。

### 常量池

紧接着主版本号之后的字节为常量池。常量池分为：常量池计数器和常量池数据区。

**常量池计数器：**由于常量的数量不固定，所以需要常量池计数器表示常量池中常量的个数。常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”。

**常量池数据区：**常量池中存储两类常量，字面量与符号引用。

字面量相当于 Java 语言层面常量的概念，如文本字符串，声明为 final 的常量值等

而符号引用则属于编译原理方面的概念。包括下面六类常量：

1. 被模块导出或者开放的包（Package）
2. 类和接口的全限定名（Fully Qualified Name）
3. 字段的名称和描述符（Descriptor）
4. 方法的名称和描述符
5. 方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）
6. 动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）

在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用需要虚拟机在运行期转换来得到真正的内存入口地址。当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。

 **Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。**

所谓静态常量池，即.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。

而运行时常量池，则是JVM虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。

常量池中每一项常量都是一个表

![图6 各类型的cp_info](https://gitee.com/StarMika/myimgs/raw/master/img/f5bdc7e8203ec666a531fcd19cdbcddc519208.png)

> Java字段名和方法名长度限制

Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度。而这里的最大长度就是length的最大值，既u2类型能表达的最大值65535。所以Java程序中如果定义了超过64KB英文字符的变量或方法名，即使规则和全部字符都是合法的，也会无法编译。

> 常量池计数器从1开始

常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”

不引用任何一个常量池项：没有父类的（Object类），没有类名的（匿名内部类）

### 访问标志

常量池结束之后的两个字节是访问标志，表示该Class是类还是接口，以及是否被Public、Abstract、Final等修饰符修饰。

![image-20220221154617191](https://gitee.com/StarMika/myimgs/raw/master/img/202202211546269.png)



### 当前类索引,父类索引与接口索引集合

类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。

类索引的值为常量池中的索引值，根据索引值就能在常量池中找到这个类的全限定名。

父类索引保存的也是常量池中的索引值，指向父类的全限定名。由于 Java 语言的单继承，所以父类索引只有一个，除了 `java.lang.Object` 之外，所有的 java 类都有父类，因此除了 `java.lang.Object` 外，所有 Java 类的父类索引都不为 0。

接口索引集合，由两部分组成：接口计数器和接口索引。接口计数器，表示该类或父类实现的接口数量。紧接着的n个字节是所有接口名称的字符串常量的索引值。

Java支持多接口，所以接口索引是一个集合，接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 `implements` (如果这个类本身是接口的话则是`extends`) 后的接口顺序从左到右排列在接口索引集合中。

对于接口索引集合，入口的第一项u2类型的数据为接口计数器（interfaces_count），表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节。

### 字段表集合

接下来是字段表计数器和字段表数据区。

字段表用于描述类和接口中声明的变量，包含类级别的变量以及实例变量，但是不包含方法内部声明的局部变量。

字段可以包括的修饰符有字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。

描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。

![图10 字段表结构](https://gitee.com/StarMika/myimgs/raw/master/img/0f795d2b2b28ce96b5963efb2e564e5a197874.png)



上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。

字段表集合中不会列出从父类或者父接口中继承而来的字段。

在Java语言中字段是无法重载的，但是对于Class文件格式来讲，只要两个字段的描述符不是完全相同，那字段重名就是合法的。

![图9 访问标志](https://gitee.com/StarMika/myimgs/raw/master/img/202202211546172.png)

### 方法表集合

方法表也是由两部分组成，方法计数器和方法表数据区。方法表数据区包括方法的权限修饰标志、方法名索引、描述符索引、属性表集合。

方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为“Code”的属性里面。

![图12 方法表结构](https://gitee.com/StarMika/myimgs/raw/master/img/d84d5397da84005d9e21d5289afa29e755614.png)

与字段表集合相对应地，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。

要重载一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名。特征签名是指一个方法中各个参数在常量池中的字段符号引用的集合，也正是因为返回值不会包含在特征签名之中，所以Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。

但是在Class文件格式之中，特征签名的范围明显要更大一些，只要描述符不是完全一致的两个方法就可以共存。

### 属性表集合

Class文件、字段表、方法表都可以携带自己的属性表集合。

方法中的代码经过Javac编译器处理之后将代码转换为JVM的执行指令，存储到方法表下的属性表中的Code属性中。Code属性中有操作数栈的最大深度，局部变量表所需的最大空间，整个方法代码的长度。

ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量（类变量）才可以使用这项属性。类似“int x=123”和“static int x=123”。

如果同时使用final和static来修饰一个变量，并且这个变量的数据类型是基本类型或者java.lang.String的话，就将会生成ConstantValue属性来进行初始化；如果这个变量没有被final修饰，或者并非基本类型及字符串，则将会选择在`类构造器<clinit>()`方法中进行初始化。

## 类加载机制

![img](https://images.xiaozhuanlan.com/photo/2020/e7675c4c23eee1e1a9ba035d7375fb84.png)

系统加载 Class 类型的文件主要三步：加载->连接->初始化。

连接过程又可分为三步:验证->准备->解析。

加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性。

解析其实是一种游离性的状态，从第一步加载Class文件字节流的时候解析可能就已经开始了，解析其实代表了连接中验证的第四步验证符号引用验证，在这里将符号引用转化为直接引用，可能随着类加载的整个流程一直在做，但解析一定是在初始化之前完成的。

### 类加载整体细节流程

整体流程：

1. 加载，静态加载，将.java文件编译为class文件，获得class文件字节流。
2. 连接中的验证第一步，文件格式验证，验证class文件中的魔数和主次版本号。
3. 加载，将class文件转化到方法区，从静态存储文件转化为运行时数据结构，将class文件里的静态常量池加载到运行时数据区中方法区中的运行时常量池。
4. 加载，在上一步把class文件加载到方法区运行时数据区后，在堆内存中生成当前类的一个class对象，作为方法区这个类的各种访问入口。
5. 连接中的验证的第二步，元数据验证。
6. 连接中的验证第三步，字节码验证。
7. 准备
8. 初始化

### 加载

加载阶段是整个类加载过程中的一个阶段。加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。

虚拟机规范对 class 文件格式进行了严格的规则，对于从哪里加载 class 文件没有严格要求。JVM实现可以从文件系统读取、从JAR(或ZIP)压缩包中提取 class 文件。除此之外也可以通过网络下载、数据库加载，甚至是运行时直接生成的 class 文件。

#### 1：加载的三个任务

加载主要完成三件事：

1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 `loadClass()` 方法）。

> 获取全限定名的方式

- 从 ZIP 包中读取，最终会改变为 JAR、EAR、WAR 格式。
- 从网络中获取，最常见的应用就是 Web Applet。
- 运行时动态生成，使用最多的就是动态代理技术。
- 由其他文件生成，比如 JSP 应用场景，由 JSP 文件生成对应的 Class 文件。
- 从数据库中读取，这种场景就比较小了。
- 可以从加密文件中获取，这是典型的防止 Class 文件被反编译的保护措施。

> 创建数组类

数组类本身不通过类加载器创建，它是**由JVM直接在内存中动态构造出来的**。数组类的元素类型（Element Type，指的是数组去掉所有维度的类型）最终还是要靠类加载器来完成加载。

- 如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型，注意和前面的元素类型区分开来）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型。
- 如果数组的组件类型不是引用类型（例如int[]数组的组件类型为int），Java虚拟机将会把数组标记在启动类加载器的命名空间上。

> 什么是命名空间

- 每个类加载器都有自己的命名空间，命名空间由加载该类的加载器及所有父加载器所加载的类组成。
- 在同一个命名空间中，不会出现类的完整名字（包括类的包名） 相同的两个类。
- 在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类。

### 验证

验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。

#### 1：验证的四个任务

**验证共有四步：**

1. 文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。
   - 是否以魔数0xCAFEBABE开头。
   - 主、次版本号是否在当前Java虚拟机接受范围之内。
   - 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。
   - 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。
   - CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。
   - Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。
   
   这阶段的认证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，后面三个阶段都是基于方法区进行的了。
   
2. 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求。
   - 这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。
   - 这个类的父类是否继承了不允许被继承的类（被final修饰的类）。
   - 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。
   - 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。
   
3. 字节码验证：这阶段就要对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。
   - 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。
   - 保证任何跳转指令都不会跳转到方法体以外的字节码指令上。
   - 保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。
   
4. 符号引用验证：
   **发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。**
   符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。
   - 符号引用中通过字符串描述的全限定名是否能找到对应的类。
   - 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。
   - 符号引用中的类、字段、方法的可访问性（private、protected、public、package）是否可被当前类访问。

### 准备

准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段，JDK1.8的类变量则会随着Class对象一起存放在Java堆中。

这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。

如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值

```java
// 准备阶段过后初始值为0，初始化后为123
public static int value = 123;
// 准备阶段过后初始值为123
public static final int value = 123;
```

### 解析

解析阶段是JVM将常量池内的符号引用替换为直接引用的过程。（由符号引用翻译出来的直接引用存储在运行时常量池中。）

- 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
- 直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。

在编译的时候一个每个 Java 类都会被编译成一个 class 文件，但在编译的时候虚拟机并不知道所引用类的地址，所以就用符号引用来代替，而在这个解析阶段就是为了把这个符号引用转化成为真正的地址的阶段。

解析也分为四个步骤：

- 类或接口的解析
- 字段解析
- 方法解析
- 接口方法解析

**注：这个阶段既可以在初始化之前执行，也可以在初始化之后执行。**

### 初始化

准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员编写的代码去初始化类变量和其他资源。

初始化，目的就是为标记常量值的字段赋值，以及执行 `<clinit>` 方法的过程。JVM虚拟机通过锁的方式确保 clinit 仅被执行一次。

#### 1：初始化过程的本质

我们也可以从另外一种更直接的形式来表达：初始化阶段就是执行类构造器`clinit方法`的过程。

1. `clinit方法`是由编译器自动收集类中的所有**类变量的赋值动作和静态语句块**（static{}块）中的语句合并产生的。
2. JVM会保证在子类的`clinit方法`执行前，父类的clinit()方法已经执行完毕。因此在Java虚拟机中第一个被执行的clinit()方法的类型肯定是java.lang.Object。
3. 由于父类的`clinit方法`先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作

> 什么情况会对类立即进行初始化

#### 2：必须初始化的6种情况

《Java虚拟机规范》则是严格规定了**有且只有**六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：

1. 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时
   - 使用new关键字实例化对象的时候。（new数组不行，new数组的字节码指令为`newArray`）
   - 读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。
   - 调用一个类型的静态方法的时候。
2. 对类型进行反射调用的时候。
3. 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
5. JDK1.8引入的被default关键字修饰的接口方法，这个接口的实现类发生了初始化，那该接口要在其之前被初始化。default关键字在接口中定义非抽象方法，default就是给接口赋予了原来抽象类的能力，实现类可以像使用抽象类的方法一样，直接使用接口里的方法。
6. 使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。

## 常量池区分

### 字符串常量池

字符串常量池（string pool）的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到字符串常量池，字符串常量池中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。

HotSpot的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot的实例只有一份，被所有的类共享。

### class文件常量池

class文件常量池，class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译器生成的**各种字面量和符号引用**。

字面量就是我们所说的常量概念，如文本字符串、被声明为final的常量值等。

符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，直接引用一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）。

常量池的每一项常量都是一个表

### 运行时常量池

运行时常量池（runtime constant pool），当java文件被编译成class文件之后，也就是会生成我上面所说的class常量池。

jvm在执行某个类的时候，必须经过**加载、连接、初始化**，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，**jvm就会将class常量池中的内容存放到运行时常量池中**，由此可知，运行时常量池也是每个类都有一个。class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。

```
String str1 = "abc";
String str2 = new String("def");
String str3 = "abc";
String str4 = str2.intern();
String str5 = "def";
System.out.println(str1 == str3);//true
System.out.println(str2 == str4);//false
System.out.println(str4 == str5);//true
```

上面程序的首先经过编译之后，在该类的class常量池中存放一些符号引用，然后类加载之后，将class常量池中存放的符号引用转存到运行时常量池中，然后经过验证，准备阶段之后，在堆中生成驻留字符串的实例对象（也就是上例中str1所指向的”abc”实例对象），然后将这个对象的引用存到全局String Pool中，也就是StringTable中，最后在解析阶段，要把运行时常量池中的符号引用替换成直接引用，那么就直接查询StringTable，保证StringTable里的引用值与运行时常量池中的引用值一致，大概整个过程就是这样了。

回到上面的那个程序，现在就很容易解释整个程序的内存分配过程了，首先，在堆中会有一个”abc”实例，全局StringTable中存放着”abc”的一个引用值，然后在运行第二句的时候会生成两个实例，一个是”def”的实例对象，并且StringTable中存储一个”def”的引用值，还有一个是new出来的一个”def”的实例对象，与上面那个是不同的实例，当在解析str3的时候查找StringTable，里面有”abc”的全局驻留字符串引用，所以str3的引用地址与之前的那个已存在的相同，str4是在运行的时候调用intern()函数，返回StringTable中”def”的引用值，如果没有就将str2的引用值添加进去，在这里，StringTable中已经有了”def”的引用值了，所以返回上面在new str2的时候添加到StringTable中的 “def”引用值，最后str5在解析的时候就也是指向存在于StringTable中的”def”的引用值，那么这样一分析之后，下面三个打印的值就容易理解了。

## 类加载器

### 三层类加载器

把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”。

站在JVM的角度来看，只存在两种不同的类加载器：一种是启动类加载器，这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。

1. **BootstrapClassLoader(启动类加载器) ：**负责加载 `%JAVA_HOME%/lib`目录下的 jar 包和类或者或被 `-Xbootclasspath`参数指定的路径中的所有类，而且是Java虚拟机能够识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中。
2. **ExtensionClassLoader(扩展类加载器)** ：主要负责加载目录 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的 jar 包。允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能，由于扩展类加载器是由Java代码实现的，开发者可以直接在程序中使用扩展类加载器来加载Class文件。
3. **AppClassLoader(应用程序类加载器)** :面向用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

### 双亲委派模型

<img src="https://images.xiaozhuanlan.com/photo/2020/cbcf86f2b1e58ad4915d67579088c023.png" alt="ClassLoader"  />

双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

### 双亲委派模型源码

```java
private final ClassLoader parent;
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // 首先，检查请求的类是否已经被加载过
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {//父加载器不为空，调用父加载器loadClass()方法处理
                        c = parent.loadClass(name, false);
                    } else {//父加载器为空，使用启动类加载器 BootstrapClassLoader 加载
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                   //抛出异常说明父类加载器无法完成加载请求
                }

                if (c == null) {
                    long t1 = System.nanoTime();
                    //自己尝试加载
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
```

先检查请求加载的类型是否已经被加载过，若没有则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。假如父类加载器加载失败，抛出ClassNotFoundException异常的话，才调用自己的findClass()方法尝试进行加载。

### 破坏双亲委派模型

只要加载类的时候不是 应用类加载器->扩展类加载器->启动类加载器这个顺序找就是打破了双亲委派机制。

1. 自定义加载器，需要继承 `ClassLoader` 。因为加载class核心的方法在`LoaderClass`类的`loadClass`方法上，如果我们不想打破双亲委派模型，就重写 `ClassLoader` 类中的 `findClass方法`即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 `loadClass方法`。

2. 线程上下文类加载器`Thread Context ClassLoader`。这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。

   这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。

> tomcat破坏了双亲委派机制

在初学时部署项目，我们是把war包放到tomcat的webapp下，这意味着一个tomcat可以运行多个Web应用程序。

那假设我现在有两个Web应用程序，它们都有一个类，叫做User，并且它们的类全限定名都一样，比如都是com.yyy.User。但是他们的具体实现是不一样的。

Tomcat给每个 Web 应用创建一个类加载器实例（WebAppClassLoader），该加载器重写了loadClass方法，优先加载当前应用目录下的类，如果当前找不到了，才一层一层往上找，那这样就做到了Web应用层级的隔离。



并不是Web应用程序下的所有依赖都需要隔离的，比如Redis就可以Web应用程序之间共享（如果有需要的话），因为如果版本相同，没必要每个Web应用程序都独自加载一份啊。

做法也很简单，Tomcat就在WebAppClassLoader上加了个父类加载器（SharedClassLoader），如果WebAppClassLoader自身没有加载到某个类，那就委托SharedClassLoader去加载。无非就是把需要应用程序之间需要共享的类放到一个共享目录下嘛。

为了隔绝Web应用程序与Tomcat本身的类，又有类加载器(CatalinaClassLoader)来装载Tomcat本身的依赖。

如果Tomcat本身的依赖和Web应用还需要共享，那么还有类加载器(CommonClassLoader)来装载进而达到共享



![图片](https://mmbiz.qpic.cn/mmbiz_jpg/E44aHibktsKYexQU7CgibSMw73fSprowKUmPt3awtOIESGe0zYKThJx7hia0qUGqMClVOXahMNepiczaHYT7iaTwWhw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



### 双亲委派模型的好处

> 顺序加载

双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载，也保证了 Java 的核心 API 不被篡改。

比如我们编写一个称为 `java.lang.Object` 类，加载时先到应用类加载器寻找，应用类加载器委托给扩展类加载器，扩展类加载器委托给启动类加载器，启动类加载器发现`%JAVA_HOME%/lib`下存在就加载`lib`下的`Object`类，而不会使用我们自己编写的`Object`类。

如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，那么程序运行的时候，系统就会出现多个不同的 `Object` 类。

> 类的唯一性和安全性

JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类。

`instanceOf`来判断自己写的`Object`，这时返回的是`false`，因为虽然包名一样，但是类被加载时使用的加载器不同。

## happen-before

指令重排虽然是能提高运行的效率，但在并发编程中，我们在兼顾「效率」的前提下，还希望「程序结果」能由我们掌控的。说白了就是：在某些重要的场景下，这一组操作都不能进行重排序，「前面一个操作的结果对后续操作必须是可见的」。

先行发生（Happens-Before），先行发生是Java内存模型中定义的两项操作之间的偏序关系。

1. 程序次序规则：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。
   注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。
2. 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。
   这里必须强调的是“同一个锁”，而“后面”是指时间上的先后。
3. volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后。
4. 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。
5. 线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。
6. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生。
7. 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。
8. 传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。

## Java编译到执行过程

![img](https://gitee.com/StarMika/myimgs/raw/master/img/ba83857ecf9f344e4972fd551c4973d653952.png@648w_454h_80q)

Java的执行过程整体可以分为两个部分，第一步由javac将源码编译成字节码，在这个过程中会进行词法分析、语法分析、语义分析，编译原理中这部分的编译称为前端编译。接下来无需编译直接逐条将字节码解释执行，在解释执行的过程中，虚拟机同时对程序运行的信息进行收集，在这些信息的基础上，编译器会逐渐发挥作用，它会进行后端编译——把字节码编译成机器码，但不是所有的代码都会被编译，只有被JVM认定为的热点代码，才可能被编译。

JVM会对「热点代码」做编译，非热点代码直接进行解释。当JVM发现某个方法或代码块的运行特别频繁的时候，就有可能把这部分代码认定为「热点代码」

##  调优的命令

![图片](https://gitee.com/StarMika/myimgs/raw/master/img/202203031149869.png)

调优参数：

- 堆栈内存相关
  - -Xms 设置初始堆的大小
  - -Xmx 设置最大堆的大小
  - -Xmn 设置年轻代大小，相当于同时配置-XX:NewSize和-XX:MaxNewSize为一样的值
  - -Xss  每个线程的堆栈大小
  - -XX:NewSize 设置年轻代大小(for 1.3/1.4)
  - -XX:MaxNewSize 年轻代最大值(for 1.3/1.4)
  - -XX:NewRatio 年轻代与年老代的比值(除去持久代)
  - -XX:SurvivorRatio Eden区与Survivor区的的比值
  - -XX:PretenureSizeThreshold 当创建的对象超过指定大小时，直接把对象分配在老年代。
  - -XX:MaxTenuringThreshold设定对象在Survivor复制的最大年龄阈值，超过阈值转移到老年代
- 垃圾收集器相关
  - -XX:+UseParallelGC：选择垃圾收集器为并行收集器。
  - -XX:ParallelGCThreads=20：配置并行收集器的线程数
  - -XX:+UseConcMarkSweepGC：设置年老代为并发收集。
  - -XX:CMSFullGCsBeforeCompaction=5 由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行5次GC以后对内存空间进行压缩、整理。
  - -XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片
- 辅助信息相关
  - -XX:+PrintGCDetails 打印GC详细信息
  - -XX:+HeapDumpOnOutOfMemoryError让JVM在发生内存溢出的时候自动生成内存快照,排查问题用
  - -XX:+DisableExplicitGC禁止系统System.gc()，防止手动误触发FGC造成问题.
  - -XX:+PrintTLAB 查看TLAB空间的使用情况



## 故障处理工具

- jstat：jstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。
- jmap：jmap(JVM Memory Map)命令用于生成heap dump文件，如果不使用这个命令，还阔以使用-XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候·自动生成dump文件。 jmap不仅能生成dump文件，还阔以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。
- jhat：jhat(JVM Heap Analysis Tool)命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。在此要注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析。
- jstack：jstack用于生成java虚拟机当前时刻的线程快照。jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。

### jps 虚拟机进程状况

jps（JVM Process Status Tool），它的功能与ps命令类似，可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main()函数所在的类）名称以及这些进程的本地虚拟机唯一ID（Local Virtual Machine Identifier,LVMID），类似于 ps -ef | grep java 的功能。

**命令格式**

```
jps [ options ] [ hostid ]
```

- options：选项、参数，不同的参数可以输出需要的信息
- hostid：远程查看

**选项列表**

| 选项 | 描述                                           |
| ---- | ---------------------------------------------- |
| -q   | 只输出进程ID，忽略主类信息                     |
| -l   | 输出主类全名，或者执行JAR包则输出路径          |
| -m   | 输出虚拟机进程启动时传递给主类main()函数的参数 |
| -v   | 输出虚拟机进程启动时的JVM参数                  |

### jcmd 虚拟机诊断命令

jcmd，是从jdk1.7开始新发布的 JVM 相关信息诊断工具，可以用它来导出堆和线程信息、查看Java进程、执行GC、还可以进行采样分析（jmc 工具的飞行记录器）。注意其使用条件是只能在被诊断的JVM同台sever上，并且具有相同的用户和组(user and group)。

**命令格式**

```
jcmd <pid | main class> <command ...|PerfCounter.print|-f file>
```

- pid，接收诊断命令请求的进程ID
  - main class，接收诊断命令请求的进程main类。
- command，接收诊断命令请求的进程main类。
- PerfCounter.print，打印目标 Java 进程上可用的性能计数器。
- -f file，从文件file中读取命令，然后在目标Java进程上调用这些命令。
- -l，查看所有进程列表信息。
- -h、-help，查看帮助信息。

### jinfo 配置信息工具

jinfo（Configuration Info for Java），实时查看和调整JVM的各项参数。

在上面讲到 `jps -v` 指令时，可以看到它把虚拟机启动时显式的参数列表都打印出来了，但如果想更加清晰的看具体的一个参数或者想知道未被显式指定的参数时，就可以通过 jinfo -flag 来查询了。

**命令格式**

```
jinfo [ option ] pid
```

###  jstat 收集虚拟机运行数据

jstat（JVM Statistics Monitoring Tool），用于监视虚拟机各种运行状态信息。它可以查看本地或者远程虚拟机进程中，类加载、内存、垃圾收集、即时编译等运行时数据。

**命令格式**

```
jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]
```

- vmid：如果是查看远程机器，需要按照此格式：`[protocol:][//]lvmid[@hostname[:port]/servername]`
- interval和count，表示查询间隔和次数，比如每隔1000毫秒查询一次进程ID的gc收集情况，每次查询5次。`jstat -gc 111552 1000 5`

**选项列表**

| 选项              | 描述                                                         |
| ----------------- | ------------------------------------------------------------ |
| -class            | 监视类加载、卸载数量、总空间以及类装载所耗费时长             |
| -gc               | 监视 Java 堆情况，包括Eden区、2个 Survivor区、老年代、永久代或者jdk1.8元空间等，容量、已用空间、垃圾收集时间合计等信息 |
| -gccapacity       | 监视内容与-gc基本一致，但输出主要关注 Java 堆各个区域使用到的最大、最小空间 |
| -gcutil           | 监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比 |
| -gccause          | 与 -gcutil 功能一样，但是会额外输出导致上一次垃圾收集产生的原因 |
| -gcnew            | 监视新生代垃圾收集情况                                       |
| -gcnewcapacity    | 监视内容与 -gcnew 基本相同，输出主要关注使用到的最大、最小空间 |
| -gcold            | 监视老年代垃圾收集情况                                       |
| -gcoldcapacity    | 监视内容与 -gcold 基本相同，输出主要关注使用到的最大、最小空间 |
| -compiler         | 输出即时编译器编译过的方法、耗时等信息                       |
| -printcompilation | 输出已经被即时编译的方法                                     |
| -gcpermcapacity   | jdk1.7 及以下，永久代空间统计                                |
| -gcmetacapacity   | jdk1.8，元空间统计                                           |

- jstat 的监视选项还是非常多的，但最常用的主要有上面这些。

### jmap 内存映射工具

jmap（Memory Map for Java），用于生成堆转储快照（heapdump文件）。

jmap 的作用除了获取堆转储快照，还可以查询finalize执行队列、Java 堆和方法区的详细信息。

**命令格式**

```
jmap [ option ] pid
```

- option：选项参数
- pid：需要打印配置信息的进程ID
- executable：产生核心dump的Java可执行文件
- core：需要打印配置信息的核心文件
- server-id：可选的唯一id，如果相同的远程主机上运行了多台调试服务器，用此选项参数标识服务器
- remote server IP or hostname： 远程调试服务器的IP地址或主机名

**选项列表**

| 选项           | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| -dump          | 生成 Java 堆转储快照。                                       |
| -finalizerinfo | 显示在F-Queue中等待Finalizer线程执行finalize方法的对象。Linux平台 |
| -heap          | 显示 Java 堆详细信息，比如：用了哪种回收器、参数配置、分代情况。Linux平台 |
| -histo         | 显示堆中对象统计信息，包括类、实例数量、合计容量             |
| -permstat      | 显示永久代内存状态，jdk1.7，永久代                           |
| -F             | 当虚拟机进程对 -dump 选项没有响应式，可以强制生成快照。Linux平台 |

### jhat 堆转储快照分析工具

jhat（JVM Heap Analysis Tool），与jmap配合使用，用于分析jmap生成的堆转储快照。

jhat内置了一个小型的http/web服务器，可以把堆转储快照分析的结果，展示在浏览器中查看。不过用途不大，基本大家都会使用其他第三方工具。

**命令格式**

```java
jhat [-stack <bool>] [-refs <bool>] [-port <port>] [-baseline <file>] [-debug <int>] [-version] [-h|-help] <file>
```

### jstack Java堆栈跟踪工具

jstack（Stack Trace for Java），用于生成虚拟机当前时刻的线程快照（threaddump、javacore）。

线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的通常是定位线程出现长时间停顿的原因，如：线程死锁、死循环、请求外部资源耗时较长导致挂起等。

线程出现停顿时通过jstack来查看各个线程的调用堆栈，就可以获得没有响应的线程在搞什么鬼。

```java
jstack [ option ] vmid
```

**选项参数**

| 选项 | 描述                                          |
| ---- | --------------------------------------------- |
| -F   | 当正常输出的请求不被响应时，强制输出线程堆栈  |
| -l   | 除了堆栈外，显示关于锁的附加信息              |
| -m   | 如果调用的是本地方法的话，可以显示c/c++的堆栈 |