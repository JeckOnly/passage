# 设计模式 

## 一：前言

### 使用设计模式的目的

设计模式的目的：使代码**可复用**。不能以算法的思想去学。所有的设计模式都是以复用性为基础，然后再来寻求**面向对象的抽象设计方案**。有可能我们在使用面向对象的语言，仍然使用着结构化的思维，所以要培养面向对象的思维。

### 应用设计模式的时机

<img src="img/重构到设计模式.png" style="zoom:45%;" />

有时候第一次写这段代码时没有用设计模式，这个很正常，因为写这段代码时还没有感受到变化。应用设计模式可以在需求变更时更好的组织代码和提高代码的可维护性。

### 重构时要关注的点

<img src="img/重构技法.png" alt="重构技法" style="zoom:50%;" />

如果代码中由左边的情况，尽量使用设计模式转到右边。



### 面向对象设计原则

面向对象的特征：

1. 封装：隐藏内部实现
2. 继承：复用现有代码
3. 多态：改写对象行为

原则：

1）

<img src="img/依赖倒置原则.png" style="zoom:50%;" />

依赖倒置原则使我想到一个例子，在仓库模式之中，ViewModel是高层模块，Repository是低层模块，然后我之前的一个错误做法就是用依赖注入给ViewModel注入具体实现，比如说：

```
class MyViewModel(val realRepository: RealRepository){...}
```

但低层模块是会变化的，当我想测试时，我想提供一个假数据的repository比如说FakeRepository，那么这个时候我就要更改ViewModel的实现，转而依赖FakeRepository。

但假如我应用**二者都应该依赖抽象**，我创建一个抽象的Repository类，里面定义抽象方法，然后ViewModel依赖这个抽象的类，我可以随意创建子类来实现repository类，然后我需要什么，就更改传进ViewModel里面的具体实现就行了。

这样软件的稳定性就得到了提高。

其实这里还使用了第6点和8点。



2）

![](img/开放封闭原则.png)

一个设计良好的类，利用各种修饰符，protected, abstract...天然就是符合开放封闭原则的。



3）

![](img/单一职责.png)

这个其实挺难应用的，有时候一个类只承担一个职责，当代码很简单的时候，却要写多个类，会在早期过度设计。



4）

![](img/子类替换原则.png)



5）

![](img/接口隔离.png)



6）

![](img/组合而不是继承.png)

其实这些原则要结合在一起看的，如果组合的类之间只暴露必要的接口（第五条），那么组合可以使得代码之间更清晰，耦合度低。



7）

![](img/封装变化点.png)



8）

![](img/针对接口编程.png)





### 为什么面向对象

变化是复用的天敌！面向对象设计模式的最大优势在于——**抵御变化**，



## 二：设计模式的分类

<img src="img/设计模式的分类.png" alt="设计模式的分类" style="zoom:50%;" />

因为设计模式出现的比较早，而Java等语言的某一些特性更新更便捷，所以一些设计模式已过时（标灰色）。

## 三：组件协作模式

![组件协作模式](img/组件协作模式.png)

### 1：Template Method

在Android中的Activity的构建流程之中，有各种handleLaunchActivity以及handleResumeActivity这些方法（稳定），这些其实就是template method——模板方法，在这些方法里面，会调用onCreate，onResume等（变化），这些方法是可以被我们应用程序重写的。这样——就在一个固定的流程之中，通过我们override某些方法，来使流程之中的操作产生了变化。

Android的这个Activity设计就用到了**模板方法**的设计模式。在Android中以on...开头的方法**大多数都是模板方法的应用**。

结构化程序流程应用模板方法的重构

<img src="img/模板方法结构化vs面向对象.png" alt="模板方法结构化vs面向对象" style="zoom:60%;" />

模板方法的类图：

![](img/dfdf.png)

模板方法的思想：

> Template Method模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制（虚函数的多态性）为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。
>
> 除了可以灵活应对子步骤的变化外，**“不要调用我，让我来调用你”的反向控制结构**是Template Method的典型应用。
>
> 在具体实现方面，被Template Method调用的虚方法可以具有实现，也可以没有任何实现(抽象方法、纯虚方法），但一般推荐将它们设置为protected方法。

### 2：策略模式

比如说，java中Array类的sort方法，要提供一个Compartor，其实就是策略模式的应用，如果不用策略模式，那在sort里面此不是要写很多if else来判断类型？而且也不支持拓展了。

另外还有一个例子就是Android中的那个动画，在Compose的那个动画中，可以设置弹簧动画也可以设置Tween动画，也是策略模式的应用——根据指定的不同策略来表现不同的动画效果。

```kotlin
if (signupScreenState.value.isLoading) {
            // 可以提供不同策略
//            rotateDegree.animateTo(360f, infiniteRepeatable(
//                TweenSpec(300)
//            ))
            rotateDegree.animateTo(360f, SpringSpec())
        }
```



### 3：Observer/Event，观察者模式

例子1：TextField的onTextChangedListener

例子2：LiveData，带上生命周期的观察者模式

其他带有addXXXListener的方法......

## 四：单一职责模式

### 1：装饰模式

例子：Java的IO库的InputStream和OutputStream。

> 在某些情况下我们可能会“过度地使用继承来扩展对象的功能”由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性;并且随着子类的增多（扩展功能的增多)，各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。

错误的例子：

```java
//业务操作
abstract class Stream {
    public abstract char read(int number);

    public abstract void seek(int position);

    public abstract void write(char data);

}

//主体类
class FileStream extends Stream {
    //读文件流
    @Override
    public  char read(int number){
        //***********
    }

    //定位文件流
    @Override
    public  void seek(int position){
        //***********
    }

    //写文件流
    @Override
    public  void write(char data){
        //***********
    }

}

class NetworkStream extends Stream {
    //读文件流
    @Override
    public  char read(int number){
        //###########
    }

    //定位文件流
    @Override
    public  void seek(int position){
        //###########
    }

    //写文件流
    @Override
    public  void write(char data){
        //###########
    }
}


class MemoryStream extends Stream {
    //读文件流
    @Override
    public  char read(int number){
        //@@@@@@@@@@@

    }

    //定位文件流
    @Override
    public  void seek(int position){
        //@@@@@@@@@@@
    }

    //写文件流
    @Override
    public  void write(char data){
        //@@@@@@@@@@@
    }
}



//扩展操作
class CryptoFileStream extends FileStream {

    @Override
    public char read(int number) {
        //额外的加密操作...

        //读文件流
        super.read(number);

    }

    @Override
    public void seek(int position) {
        //额外的加密操作...

        //定位文件流
        super.seek(position);

        //额外的加密操作...

    }

    //写内存流
    @Override
    public void write(char data) {
        //额外的加密操作...

        //写文件流
        super.write(data);

        //额外的加密操作...
    }
}

class CryptoNetworkStream extends NetworkStream {


    @Override
    public char read(int number) {
        //额外的加密操作...

        //读网络流
        super.read(number);
    }

    @Override
    public void seek(int position) {
        //额外的加密操作...

        //定位网络流
        super.seek(position);

        //额外的加密操作...
    }


    @Override
    public void write(char data) {
        //额外的加密操作...

        //写网络流
        super.write(data);

        //额外的加密操作...
    }
}


class CryptoMemoryStream extends MemoryStream {


    @Override
    public char read(int number) {
        //额外的加密操作...

        //读内存流
        super.read(number);
    }

    @Override
    public void seek(int position) {
        //额外的加密操作...

        //定位内存流
        super.seek(position);

        //额外的加密操作...
    }

    //写内存流
    @Override
    public void write(char data) {
        //额外的加密操作...

        //写内存流
        super.write(data);

        //额外的加密操作...
    }
}


class BufferedFileStream extends FileStream {

}

class BufferedNetworkStream extends NetworkStream {

}

class BufferedMemoryStream extends MemoryStream {

}

class CryptoBufferedFileStream extends FileStream {


    @Override
    public char read(int number) {
        //额外的加密操作...
        //额外的缓冲操作...

        //读文件流
        super.read(number);

        //额外的加密操作...
        //额外的缓冲操作...

    }

    @Override
    public void seek(int position) {
        //额外的加密操作...
        //额外的缓冲操作...
        //定位文件流

        super.seek(position);

        //额外的加密操作...
        //额外的缓冲操作...
    }

    @Override
    public void write(char data) {
        //额外的加密操作...
        //额外的缓冲操作...

        //写文件流
        super.write(data);
        
        //额外的加密操作...
        //额外的缓冲操作...
    }
}


class Client {

    public static void main(String args[]) {

        //编译时装配
        CryptoFileStream fs1 = new CryptoFileStream();

        BufferedFileStream fs2 = new BufferedFileStream();

        CryptoBufferedFileStream fs3 = new CryptoBufferedFileStream();

    }
}
```

缺点

1. 这个继承关系使得有很多的代码没有复用，比如说那些加密/缓冲操作，其实都是相同的。
2. 类的数量急剧上升![](img/dfdfdf.png)



重构：

> 如何使“对象功能的扩展”能够根据需要来动态地实现?同时避免“扩展功能的增多”带来的子类膨胀问题?从而使得任何“功能扩展变化”所导致的影响将为最低?

根据重构技法，我们要朝着：编译时依赖——> 运行时依赖，静态——> 动态 的目标前进，在继承时，调用super.func()属于编译时依赖，因为super的类型是确定的，不够灵活，所以我们要**继承转组合**，在拓展类中加一个Stream类型的字段，然后为了**满足接口调用的统一**，拓展类再继承Stream类。

```java
//业务操作
abstract class Stream {
    public abstract char read(int number);

    public abstract void seek(int position);

    public abstract void write(char data);

}

//主体类
class FileStream extends Stream {
    //读文件流
    @Override
    public  char read(int number){
        //***********
    }

    //定位文件流
    @Override
    public  void seek(int position){
        //***********
    }

    //写文件流
    @Override
    public  void write(char data){
        //***********
    }

}

class NetworkStream extends Stream {
    //读文件流
    @Override
    public  char read(int number){
        //###########
    }

    //定位文件流
    @Override
    public  void seek(int position){
        //###########
    }

    //写文件流
    @Override
    public  void write(char data){
        //###########
    }
}


class MemoryStream extends Stream {
    //读文件流
    @Override
    public  char read(int number){
        //@@@@@@@@@@@

    }

    //定位文件流
    @Override
    public  void seek(int position){
        //@@@@@@@@@@@
    }

    //写文件流
    @Override
    public  void write(char data){
        //@@@@@@@@@@@
    }
}



//继承：接口协议
class CryptoStream extends Stream  {

    //组合：复用实现
    Stream s;// s=new FileStream(); s=new NetworkStream(); s=new MemoryStream();

    public CryptoStream(Stream s)
    {
        this.s=s;
    }

    @Override
    public char read(int number) {
        //额外的加密操作...

        //读文件流
        s.read(number);

    }

    @Override
    public void seek(int position) {
        //额外的加密操作...

        //定位文件流
        s.seek(position);

        //额外的加密操作...

    }

    //写内存流
    @Override
    public void write(char data) {
        //额外的加密操作...

        //写文件流
        s.write(data);

        //额外的加密操作...
    }
}




class BufferedStream extends Stream {
    Stream s;

    public BufferedStream(Stream s)
    {
        this.s=s;
    }

}







class Client {

    public static void main(String args[]) {

        //运行时装配

        Stream s1=new CryptoStream( new FileStream());

        Stream fs2 = new BufferedStream(new FileStream());

        Stream fs3 = new CryptoStream(new BufferedStream(new FileStream()));


    }
}
```

优点：

1. 复用拓展类的代码
2. 类的数量大大减少



进一步，在拓展类中都有一个Stream类型的字段，我们再把这个**既组合父类也继承父类**的特性抽象出来，成为一个Decorator类。

```java
//业务操作
abstract class Stream {


    public abstract char read(int number);

    public abstract void seek(int position);

    public abstract void write(char data);

}

//主体类
class FileStream extends Stream {
    //读文件流
    @Override
    public  char read(int number){
        //***********
    }

    //定位文件流
    @Override
    public  void seek(int position){
        //***********
    }

    //写文件流
    @Override
    public  void write(char data){
        //***********
    }

}

class NetworkStream extends Stream {
    //读文件流
    @Override
    public  char read(int number){
        //###########
    }

    //定位文件流
    @Override
    public  void seek(int position){
        //###########
    }

    //写文件流
    @Override
    public  void write(char data){
        //###########
    }
}


class MemoryStream extends Stream {
    //读文件流
    @Override
    public  char read(int number){
        //@@@@@@@@@@@

    }

    //定位文件流
    @Override
    public  void seek(int position){
        //@@@@@@@@@@@
    }

    //写文件流
    @Override
    public  void write(char data){
        //@@@@@@@@@@@
    }
}

//继承：接口协议
abstract  DecoratorStream extends Stream{
    //组合：复用实现
    protected Stream s;// s=new FileStream(); s=new NetworkStream(); s=new MemoryStream();

    protected DecoratorStream(Stream s){
        this.s=s;
    }
}



class CryptoStream extends DecoratorStream  {


    public CryptoStream(Stream s)
    {
        super(s);
    }

    @Override
    public char read(int number) {
        //额外的加密操作...

        //读文件流
        s.read(number);

    }

    @Override
    public void seek(int position) {
        //额外的加密操作...

        //定位文件流
        s.seek(position);

        //额外的加密操作...

    }

    //写内存流
    @Override
    public void write(char data) {
        //额外的加密操作...

        //写文件流
        s.write(data);

        //额外的加密操作...
    }
}




class BufferedStream extends DecoratorStream {
    Stream s;

    public BufferedStream(Stream s)
    {
        super(s);
    }

    //....
}







class Client {

    public static void main(String args[]) {

        //运行时装配

        FileStream fs=new FileStream();

        Stream s1=new CryptoStream( new FileStream());

        Stream s2 = new BufferedStream(new FileStream());

        Stream s3 = new CryptoStream(new BufferedStream(new FileStream()));


    }
}
```

![](img/tyty.png)

红色是不变的，蓝色是变化点。

应用装饰模式可以方便地复用拓展代码。